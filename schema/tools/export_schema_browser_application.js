const fs = require('fs');
const helpers = require('./helpers');
const path = require('path');

const entityHierarchyPath = path.resolve('../entityHierarchy/thing/Item');
const predicateHierarchyPath = path.resolve('../predicateHierarchy/predicate');
const outputFile = './schema.ts';

function getHeader() {
  return `//
//  WARNING: THIS FILE IS AUTOGENERATED; DO NOT CHANGE.
//  Visit https://gitlab.memri.io/memri/schema to learn more.
//
//  schema.ts
//
//  Copyright Â© 2020 memri. All rights reserved.
//

import {decodeEdges, jsonErrorHandling} from "../gui/util";
import {Color} from "../parsers/cvu-parser/CVUParser";

`;
}

function getItemFamily() {
  // The Item family.
  let output = '// The family of all data item classes\n' +
    'enum ItemFamily {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Item'].includes(entity)) continue; // TODO global
    output += `    type${entity} = "${entity}",\n`;
  }
  output += '}\n'

  output += '\nexport var discriminator = Discriminator._type\n\n';

  // Background colors.
  output += 'export var backgroundColor = function(name) {\n' +
    '    switch (name) {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Item'].includes(entity)) continue; // TODO global
    output += `        case ItemFamily.type${entity}: return new Color("${entityHierarchy[entity]['backgroundColor']}")\n`; // TODO
  }
  output += '    }\n' +
    '}\n\n';

  // Foreground colors.
  output += 'export var foregroundColor = function(name) {\n' +
    '    switch (name) {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Item'].includes(entity)) continue; // TODO global
    output += `        case ItemFamily.type${entity}: return new Color("${entityHierarchy[entity]['foregroundColor']}")\n`; // TODO
  }
  output += '    }\n' +
    '}\n\n';

  // Get primary key functions.
  output += 'export var getPrimaryKey = function(name) {\n' +
    '    return new getItemType(name)().primaryKey() ?? \"\"\n' +
    '}\n\n';

  // Get type functions.
  output += 'export var getItemType = function(name) {\n' +
    '    switch (name) {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Item'].includes(entity)) continue; // TODO global
    output += `        case ItemFamily.type${entity}: return ${entity}\n`;
  }
  output += '    }\n' +
    '}\n';
  return output;
}

function getDataItemClasses() {
  let output = '';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Datasource', 'UserState', 'ViewArguments'].includes(entity)) continue; // Datasource and UserState are defined elsewhere.
    let description = `\n/// ${entityHierarchy[entity]['description']}\n`;
    output += helpers.wrapText(description, 100, '\n/// ');

    // A set of Items needs to be prepended with 'Schema' for front end functionality
    switch (entity) {
      case 'Item':
        output += `export class SchemaItem {\n`;
        break;
      case 'Session':
        output += `export class SchemaSession extends Item {\n`;
        break;
      case 'Sessions':
        output += `export class SchemaSessions extends Item {\n`;
        break;
      case 'Person':
        output += `export class SchemaPerson extends Item {\n`;
        break;
      case 'SyncState':
        output += `export class SyncState {\n`;
        break;
      case 'Edge':
        output += `export class Edge {\n`;
        break;
      case 'Datasource':
      case 'UserState':
        continue;
      default:
        output += `export class ${entity} extends Item {\n`;
    }

    // Properties.
    let dynamicVars = "";
    let dynamicVarsDecoder = "";

    let realmOptionals = "";
    let realmOptionalsDecoder = "";

    let relations = "";
    let relationsDecoder = "";

    let codingKeys = [];

    for (let property of entityHierarchy[entity]['properties']) {
      // Skip properties already defined in 'Item', as in swift the only inheritance is that every Item extends 'Item'.
      if (entityHierarchy['Item']['properties'].includes(property) && !['Item', 'Edge'].includes(entity) || ['genericType', 'functions'].includes(property)) {
        continue;
      } else if (entity === 'Edge') {
        // console.log(entity, property) // TODO remove scaffolding
      }
      if (Object.keys(predicateHierarchy).includes(property)) {
        if (!['changelog', 'label'].includes(property)) codingKeys.push(property);
        let type = predicateHierarchy[property]['expectedTypes'];
        if (property === 'allEdges') {
          output += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          output += '    allEdges = []\n';
          relationsDecoder += '        decodeEdges(decoder, "allEdges", this)\n';
        } else if (property === 'updatedFields') {
          output += '    updatedFields = []\n';
        } else if (['version', 'currentViewIndex', 'currentSessionIndex'].includes(property)) {
          dynamicVars += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          dynamicVars += `    ${property}: number = 0\n`;//TODO Ani
          dynamicVarsDecoder += `            this.${property} = decoder.decodeIfPresent("${property}") ?? this.${property}\n`;
        } else if (type === 'string') {
          dynamicVars += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          dynamicVars += `    ${property}\n`;
          if (property === 'targetItemType') {
            dynamicVarsDecoder += `            this.${property} = decoder.decodeIfPresent("itemType") ?? this.${property}\n`;
          } else if (property !== 'sourceItemType') {
            dynamicVarsDecoder += `            this.${property} = decoder.decodeIfPresent("${property}") ?? this.${property}\n`;
          }
        } else if (type === 'datetime') {
          dynamicVars += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          dynamicVars += `    ${property}: Date\n`;
          dynamicVarsDecoder += `            this.${property} = decoder.decodeIfPresent("${property}") ?? this.${property}\n`;
        } else if (type === 'bool') {
          dynamicVars += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          dynamicVars += `    ${property}: boolean = false\n`;
          dynamicVarsDecoder += `            this.${property} = decoder.decodeIfPresent("${property}") ?? this.${property}\n`;
        } else if (type === 'int') {
          realmOptionals += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          realmOptionals += `    ${property}\n`;
          if (property === 'targetItemID') {
            realmOptionalsDecoder += `            this.${property}.value = decoder.decodeIfPresent("uid") ?? this.${property}.value\n`;
          } else if (property !== 'sourceItemID') {
            realmOptionalsDecoder += `            this.${property}.value = decoder.decodeIfPresent("${property}") ?? this.${property}.value\n`;
          }
        } else if (type === 'float') {
          realmOptionals += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          realmOptionals += `    ${property}\n`;
          realmOptionalsDecoder += `            this.${property}.value = decoder.decodeIfPresent("${property}") ?? this.${property}.value\n`;
        } else if (type === 'any') {
          if (entity === 'Item') continue;
          relations += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          relations += `    get ${property}() {\n` +
            `        return this.edges("${property}")?.itemsArray()\n` +
            `    }\n\n`;
        } else {
          if (entity === 'Item') continue;
          relations += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          relations += `    get ${property}() {\n` +
            `        return this.edges("${property}")?.items(${type})\n` +
            '    }\n\n';
        }
      } else if (property.substring(0, 4) === 'one_') {
        property = property.substring(4);
        if (!predicateHierarchy[property]) continue; //TODO Ani
        let type = predicateHierarchy[property]['expectedTypes'];
        codingKeys.push(property);
        if (['Item', 'Edge'].includes(entity)) {
          if (property === 'edgeLabel') {
            dynamicVars += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
            dynamicVars += `    ${property}\n`;
            dynamicVarsDecoder += `            this.${property} = decoder.decodeIfPresent("${property}") ?? this.${property}\n`;
          } else {
            dynamicVars += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
            dynamicVars += `    ${property}\n`;
            dynamicVarsDecoder += `            this.${property} = decoder.decodeIfPresent("${property}") ?? this.${property}\n`;
          }
        } else {
          relations += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
          relations += `    get ${property}() {\n` +
            `        return this.edge("${property}")?.target(${type})\n` +
            '    }\n\n';
        }
      } else if (property.substring(0, 10) === 'sequenced_') {
        property = property.substring(10);
        if (!predicateHierarchy[property]) continue; //TODO Ani
        let type = predicateHierarchy[property]['expectedTypes'];
        relations += helpers.wrapText('    /// ' + predicateHierarchy[property]['description'] + '\n', 96);
        if (property === 'views') {
          relations += `    get ${property}() {\n` +
            `        return this.edges("view")?.sorted("sequence").items(${type})\n` +//TODO Ani sorted
            '    }\n\n';
        } else if (property === 'sessions') {
          relations += `    get ${property}() {\n` +
            `        return this.edges("session")?.sorted("sequence").items(${type})\n` +//TODO Ani sorted
            '    }\n\n';
        } else {
          relations += `    get ${property}() {\n` +
            `        return this.edges("${property}")?.sorted("sequence").items(${type})\n` +//TODO Ani sorted
            '    }\n\n';
        }
      } else {
        console.log(`Error while processing, item "${entity}" has non existent field "${property}"`);
      }
    }
    output += dynamicVars;
    output += realmOptionals;
    if (dynamicVars || realmOptionals) output += '\n';
    output += relations;

    // Decoder
    if (entity === 'Item') {
      output += '    superDecode(decoder: Decoder) {\n';
    } else {
      output += '    constructor(decoder) {\n';
    }
    if (['Item'].includes(entity)) {
      // output += '        self.init()\n\n'; // TODO
    } else {
      output += '        super()\n';
    }
    if (entity !== 'Item') {
      output += '        \n' +
        '        jsonErrorHandling(function () {\n';
    }
    if (entityHierarchy[entity]['properties']) {
      output += relationsDecoder;
      output += dynamicVarsDecoder;
      output += realmOptionalsDecoder;
    }
    if (entity === 'Item') {
      output += '    }\n\n' +
        '    /*enum CodingKeys {\n' +
        '        ' + helpers.wrapText(codingKeys.join(', ') + '\n', 92, '\n            ');
    } else if (entity === 'Edge') {
      output += '\n            this.parseTargetDict(decoder.decodeIfPresent("target"))\n'
    } else if (entity === 'SyncState') {
    } else {
      output += '\n            this.superDecode(decoder)\n';
    }

    if (entity !== "Item") {
      output += '        }.bind(this))\n';
    } else {
      output += '        }*/\n';
    }
    output += '    }\n' +
      '}\n';
  }
  return output;
}

function getDataItemListToArray() {
  let output = '\nexport function dataItemListToArray(object) {\n' +
    '    var collection = []\n' +
    '    if (!Array.isArray(object) || !object.length) return\n';
  for (const [index, entity] of Object.keys(entityHierarchy).entries()) {
    if (['Datasource', 'SyncState', 'UserState', 'ViewArguments'].includes(entity)) continue;
    if (index !== 0) {
      output += '    else ';
    } else {
      output += '    ';
    }
    if (entity === 'Edge') {
      output += 'if (object[0] instanceof Edge) { return object.itemsArray() }\n';
    } else {
      output += `if (object[0] instanceof ${entity}) { object.forEach(function (item) {collection.push(item)}) }\n`;
    }
  }
  output += '\n    return collection\n' +
    '}\n';

  return output;
}

let entityHierarchy = {};
let predicateHierarchy = {};
(async () => {
  await helpers.getHierarchy(entityHierarchyPath, entityHierarchy, entityHierarchyPath, 'Item');
  await helpers.getHierarchy(predicateHierarchyPath, predicateHierarchy, predicateHierarchyPath, 'predicate');

  let output = getHeader();
  output += getItemFamily();
  output += getDataItemClasses();
  output += getDataItemListToArray();

  console.log(output)

  fs.writeFile(outputFile, output, (err) => {
    if (err) throw err;
    console.log('File saved as ' + outputFile);
  });
})();
